# strcpy() Vulnerability Explained (CTF-Focused)

## What strcpy() Does

strcpy() copies bytes from a source string into a destination buffer until it encounters a null byte (`\0`).  
It performs **no bounds checking**. It does not know how large the destination buffer is.  
It assumes the programmer allocated enough space.

That assumption is usually wrong.

---

## Why strcpy() Is Inherently Dangerous

The function signature already tells you everything:

char *strcpy(char *dest, const char *src)

There is:
- no length argument
- no automatic safety
- no runtime protection

If `src` is larger than `dest`, strcpy() will continue writing past the allocated buffer and overwrite adjacent memory.

This is not undefined behavior.  
This is **documented behavior**.

---

## The Core Vulnerability

In C, memory is laid out sequentially.  
When you overflow a buffer, you do not stop — you keep writing into whatever comes next.

On the stack, that usually means:
- other local variables
- saved base pointer (RBP)
- saved return address (RIP / EIP)

Once the return address is overwritten, execution flow is no longer trusted.

That is the exploit.

---

## Typical Vulnerable Pattern in CTFs

A common vulnerable logic looks like this:

- A fixed-size buffer is allocated on the stack
- User input is copied into it using strcpy()
- No length validation is performed
- The function returns

If the input exceeds the buffer size, attacker-controlled data reaches control-flow structures.

This is intentional in CTF challenges.

---

## Stack Memory Layout (Simplified)

When a function is called, the stack usually looks like this:

- saved return address
- saved base pointer
- local variables (buffers, integers, etc.)

If a buffer is declared last and overflowed, it overwrites upward into saved control data.

strcpy() makes this trivial.

---

## How Exploitation Works (Conceptually)

The attacker provides an input string that is:

1. Long enough to fill the buffer
2. Long enough to reach the return address
3. Carefully crafted so the overwritten return address points somewhere useful

In beginner CTFs, that “useful place” is often:
- a win() function
- a hidden function
- code that prints a flag

No shellcode needed. No complexity. Just redirection.

---

## Why CTF Designers Love strcpy()

Because it:
- behaves consistently
- fails loudly
- teaches stack fundamentals
- does not depend on race conditions
- is easy to reason about

It forces players to understand:
- stack layout
- offsets
- calling conventions

If you understand strcpy(), you understand classic stack overflows.

---

## Why strcpy() Is Worse Than It Looks

You cannot make strcpy() safe.

Even if you “trust the input”:
- environment variables can be long
- argv values can be long
- file input can be long

Any use of strcpy() with external input is a bug.

Period.

---

## Real-World Mitigations (Often Disabled in CTFs)

Modern systems use:
- stack canaries
- ASLR
- NX (non-executable stack)
- fortified libc checks

CTFs often disable these so the vulnerability is exploitable instead of theoretical.

---

## Bottom Line

If you see strcpy() in C code:

- assume a buffer overflow
- assume memory corruption
- assume control-flow hijacking
- assume it’s exploitable

In CTFs, strcpy() is not a mistake.  
It’s a **deliberate invitation**.

---
